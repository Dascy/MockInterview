#### JVM

##### JVM内存区域划分

由堆、栈、方法区、程序计数器组成。

| 堆 （运行时常量池）     | new的对象就会放在堆中  数组              |
| -------------- | ----------------------------- |
| 栈 （JVM栈和本地方法栈) | 局部变量(基本数据类型)和对象引用类型           |
| 方法区            | 加载好的类放在方法区，常量、静态变量            |
| 程序计数器          | 存储的是地址描述的是当前线程接下来 要执行的指令在什么地方 |

JVM栈与本地方法栈（Native Method Stack）的主要区别在于 本地方法栈执行native方法(非Java语言实现的接口)

##### native方法的引用

Unsafe.class下存在native方法引用。

native 关键字修饰接口，说明该接口在外部定义。使用非Java语言实现。

```java
//native 的使用 cd 到target/class下 需要使用 javah  包名+类名 命令 生成 C的头文件。在里面实现C的代码
public class HelloJni {
    static {
        System.loadLibrary("hello");
    }

     private  native void sayHello();

    public static void main(String[] args) {
            new HelloJni().sayHello();
    }
}


```

##### GC垃圾回收机制

###### 引用计数法

​      通俗的来说就是每一个程序有一个计数器，当程序被引用的时候计数器加1，引用失效计数器减1。计数器为0的对象表示不可用。

​       缺点：两个对象互相引用的时候，计数器都不为0.无法被回收。

JVM虚拟机没有使用这种方法。

###### 可达性分析算法

​      以 GC Roots 为根，向下搜索。搜索走过的路径称为引用链，如果一个对象与GC Roots 之间不存在联通的引用链。即不可达。认为该对象可回收。

###### 标记-清除算法

分为标记和清理两个阶段。标记阶段标记所有要回收的对象。清理阶段清理这些对象

缺点是：效率不高，清理后会产生大量内存不连续的碎片。导致分配给大对象时内存不足需要提前触发回收。

###### 复制算法（新生代回收算法）

将内存划分为大小相等的块，当一块内存使用结束的时候，将该区域存活的对象复制到另一块内存区域。然后回收当前内存区域。

缺点：内存缩小为原来的一半。

###### 标记-整理算法

在标记-清理的基础上，增加一步整理的功能。在清楚前，将有存活对象的内存区域向一端移动，然后清理边界之外的内存区域。

###### 分代收集算法

将内存分为新生代和老年代。新生代是生命周期短。新生代的对象因为生命周期短，所以使用复制算法进行回收。老年代的生命周期长，使用标记-整理或者标记-清除算法。

##### JVM调优常用参数

- -Xmx1024m：最大堆内存，当物理内存不超过192m时最大堆内存为物理内存的一半，否则为物理内存的四分之一
- -Xms1024m：最小堆内存，一般设置为与-Xmx同等值
- -XX:+PrintGCDetails：输出gc详细日志
- -XX:+PrintGCTimeStamps或-XX:+PrintGCDateStamps：输出gc信息时带上时间戳


- jcmd：专用于查看JVM状态，可以查看正在运行的进程，会显示出进程号

##### JVM分析堆内存溢出步骤

1.查看日志，看日志能不能定位内存溢出的原因

2.top 后 shift+M 按内存占用大到小排序，RES 是此进程实际占用内存，%MEM是占服务器总内存的49.8%

3.使用ps -aux|grep java 查看pid

4.利用 jstat 查看虚拟机 gc 情况

5.利用 jmap 直接生成 dump 文件

6.分析dump 文件 （MAT 或者 jvisualvm）

#### 集合相关问题

##### ArrayList 和 LinkedList的区别

ArrayList的底层实现是数组。LinkedList的底层实现是链表。

两者在查询方面的区别：ArrayList更适合查询。但是如果只是获取首个元素或者尾部元素。查询效率是一致的。

两者在插入方面的区别：ArrayList 插入指定位置或者末尾位置很快。但是数量大的时候需要扩容。LinkedList不存在扩容问题。但是向指定位置插入因为要遍历链表会降低效率。

综上：如果仅仅是使用add做插入。使用LinkedList会好一些。如果插入场景少，经常查询通常使用ArrayList。

##### HashMap实现

数组+链表实现的

##### HashMap put方法的实现

1.将key和value封装成一个node节点。

2.调用底层的hashCode()方法。计算hash值

3.通过哈希算法将hash值转换为下标值，如果该下标值的数组不存在node，就存放进去。

4.如果存在node。比较他们的key和value。key一致，就替换。不一致就与链表的下一个节点进行比较。直到链表尾部都不一致。添加节点到链表尾部。

##### HashMap get方法的实现

1.通过key的hashCode计算hash值。然后通过哈希算法转换成下标。

2.下标位置的数组不存在节点。返回null

3.下标位置的数组存在节点。则用key与链表的每一个key值比较。如果所有的结果都为false，返回null。匹配则返回value。

#### 多线程

##### volatile

###### 定义

Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致地更新，线程应该确保通过排他锁单独获取这个变量。

Java字段被该变量声明，则所有线程看到这个变量的值是一致的。

###### 实现原理

被volatile修饰的的变量，在转换为汇编语言的时候，会多出Lock前缀的指令。处理器在处理Lock前缀指令的时候会做两件事情：

- 将当前处理器的缓存行的数据写回到系统内存中。
- 写回内存的操作会因为缓存一致性协议导致其他CPU里缓存的内存地址无效。

###### volatile优化

JDK7中新增了LinkedTransferQueue。使用了追加字节的方式来进行了出队和入队的性能优化。

##### synchronized

- 修饰同步方法，锁对象是当前示例对象。
- 修饰静态同步方法，锁对象是当前类的class对象。
- 修饰同步方法块，锁对线是Synchronized括号里配置的对象。

###### 实现原理

JVM基于进入和退出monitor对象来实现同步。也就是monitorenter和monitorexit指令。任何一个对象都对应一个monitor。代码块同步在编译完成后，会在开始处插入monitorenter。在结束或者异常处插入monitorexit。当一个monitor被持有后，即为锁定状态。线程执行到monitorenter指令处会尝试获取monitor的所有权，即尝试获取锁对象。

##### 锁升级



##### 多线程的创建与执行

###### 线程的创建

```java
Thread thread = new Thread();

class a implements Runnable{}

@Async

@EnableAsync
```

###### 线程的执行

```
thread.start();
```



##### 线程池

###### 实现原理

- 线程池判断核心线程池里面的线程数是否都在执行任务。不是，创建一个线程执行当前任务。是进入下一步
- 线程池判断工作队列是否已经满了。没满就添加进去，满了就进入下一步
- 线程池判断线程数是否达到最大线程数。没有就创建线程来执行任务。如果已经满了就交给饱和策略来处理。

###### 饱和策略

- AbortPolicy        直接抛出异常
- CallerRunsPolicy   只用调用者所在线程来运行任务
- DiscardOldestPolicy  丢弃队列里最近一个任务，执行当前任务
- DiscardPolicy  不处理，丢弃 

###### 关键参数

- 核心线程数 corePoolSize
- 最大线程数 maxinumPoolsize
- 线程活跃时间  keepAliveTime  线程空闲时间保持存活的时间
- 线程活动保持时间的单位 TimeUnit
- 任务队列 runnableTaskQueue 
- 线程工厂  ThreadFactory  可以给线程命名
- 饱和策略  RejectedExecutionHandler  

###### 任务队列

- ArrayBlockingQueue 数组结构的阻塞队列
- LinkedBlockingQueue  链表结构的队列
- SynchronousQueue  不存储元素的阻塞队列
- PriorityBlockingQueue  具有优先级的无限阻塞队列 

###### 线程池提交任务

**execute**

直接执行无返回结果

**submit**

返回一个Future对象,可以使用get方法获取返回值。但是会阻塞当前线程

###### 线程的关闭

shutdown 或者shutdownNow

shutdown将线程状态设置为SHUTDOWN 然后中断没有执行任务的线程

shutdownNow 会将所有线程设置为STOP 然后中断线程。

调用之后使用isShutdown获取到true  使用isTerminaed需要等线程真正关闭才会返回true

###### 线程池的合理配置

- CPU密集型的任务，线程池配置为CPU数+1
- IO密集型任务，尽可能多的配置线程数
- 混合型，如果可以拆分。依照上述策略。如果拆分后执行时间相差较大，就没必要了。
- 优先级不同的任务，可以使用优先级队列来处理。
- 执行时间不同的任务可以设置不同的线程池来执行
- 依赖其他系统资源的任务，就尽量设置多一些的线程数。

###### 线程池监控

- taskCount
- completeTaskCount
- largestPoolSize
- getPoolSize
- getActiveCount

###### 通过ThreadPoolExecutor 创建的线程池

```java
ThreadPoolExecutor poolExecutor =
  new ThreadPoolExecutor(corePoolSize,maxinunmPoolsize,keepAliveTime,TimeUnit.HOURS,queue,threadFactory,  handler);
```

######  Executors 

**包括：**

-    Executors.newFixedThreadPool：创建⼀个固定⼤⼩的线程池，可控制并发的线程数，超出的线程会在队列中等待；
-    Executors.newCachedThreadPool：创建⼀个可缓存的线程池，若线程数超过处理所需，缓存⼀段时间后会回收，若线程数不够，则新建线程；
-    ​    Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执⾏顺序；
-    ​    Executors.newScheduledThreadPool：创建⼀个可以执⾏延迟任务的线程池；
-    ​    Executors.newSingleThreadScheduledExecutor：创建⼀个单线程的可以执⾏延迟任务的线程池；
-    ​    Executors.newWorkStealingPool：创建⼀个抢占式执⾏的线程池（任务执⾏顺序不确定）【JDK1.8 添加】。
-    ​    ThreadPoolExecutor：最原始的创建线程池的⽅式，它包含了 7 个参数可供设置，后⾯会详细讲。

#### 注解相关

##### @Autowired和@Resource注解的区别是什么？

@Autowired 由Spring提供，只按照byType注入  可以使用@Qualifier byName

 @Resource 由J2EE提供，默认按照byName自动注入

#### 设计模式

##### 单例模式

```json
/**
 * 
 * @ClassName: Singleton
 * @Description: 懒汉式单例（在第一次调用的时候实例化自己）
 * 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，
 *   所以严格意义上它并不算单例模式。
 */
public class Singleton {
	//构造函数私有化
	private Singleton(){}
	
	private static Singleton singleton = null;
	
	//构建实例化方法
	public static Singleton getSingleton(){
		if(singleton == null){
			singleton = new Singleton();
		}
		return singleton;
	}
}
```

```java
/**
 * 
 * @ClassName: Singleton2
 * @Description: 饿汉式
 * 这种方式比较常用，但容易产生垃圾对象。
 * 优点：没有加锁，执行效率会提高。
 * 缺点：类加载时就初始化，浪费内存。
 */
class Singleton2 {
        //私有构造函数
	private Singleton2(){};
	private static Singleton2 singleton2= new Singleton2();
	public static Singleton2 getSingleton2(){
		return singleton2;
	}
}
```

#### 通信协议

##### http

超文本传输协议,HTTP 是一个基于TCP/IP通信协议来传递数据。

##### 工作原理





#### 框架

##### SpringMVC

###### 实现原理

1.用户访问网页提交request请求

2.前端控制器（dispatcherServlet）接收用户请求与响应

3.前端控制器调用处理映射器（handleMapping）解析请求对应的 `Handler`

4.解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。

5.HandlerAdapter` 会根据 `Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。

6.处理器处理完业务后，会返回一个 `ModelAndView` 对象。

7.ViewResolver(视图解析器) modelAndView对象返回真正的视图view

8.DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。`

9.把 View返回给请求者（浏览器）

##### SpringBoot

###### 为什么使用微服务

- 目前模块包拆分粒度比较细但未成体系/层次结构，很难化配出独立运行的应用
- 服务调用还停留在单体应用中方法调用的程度上，导致提供的应用过于臃肿
- 使用的技术框架较为老化，技术新特性很难应用在当前项目中
- 原应用的配置文件过于繁杂，应使用主流的编程式+文件式配置逐步替代

###### 核心注解

@SpringBootApplication

1. SpringBootConfiguration     声明当前类是SpringBoot应用的配置类
2. EnableAutoConfiguration    开启自动配置
3. ComponentScan  扫描Spring组件  basePackages 指定路径


#### Linux

##### 常用命令

```shell
ls 查看列表
cd 进入目录
pwd 查看当前路径
free 查看内存
tail 用于显示指定文件末尾内容
which     查看可执行文件的位置。
whereis 查看文件的位置。
locate  配合数据库查看文件位置。
find        实际搜寻硬盘查询文件名称。
chmod 改变linux权限
chown  -R  XX   路径   改变文件所有者
```

#### Mysql

##### Mysql存储引擎

5.5版本之前默认的MyISAM存储引擎。现在默认的是Innodb存储引擎。

###### MyISAM

MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎。

MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不支持外键

###### Innodb

 支持行级锁(row-level locking)和表级锁,默认为行级锁,支持事务。支持崩溃后恢复。支持外键。

##### Mysql索引原理

