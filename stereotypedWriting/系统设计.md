#### 系统设计

##### 写在前面的话

说是系统设计，其实只是写面试遇到的设计类题目。希望总结下来能对自己有帮助

##### 后台系统登录一般流程

1. 异步请求后端得到验证码。验证码图片以base64的编码和uuid返回前端
2. 根据用户名和密码、验证码值、uuid传递到后端，为了效率，先判断验证码值是否正确，正确的话，再根据用户名查询出角色权限及密码，进行密码判断
3. 如果密码错误，记录操作次数。操作达上线用户停用。并返回前端提示
4. 密码正确则生成token并缓存到Redis中
5. 返回token及权限信息

##### 登录成功后二次访问后台的鉴权逻辑

1. 后台使用AOP对controller层进行权限校验
2. 在切面中会存储合法的请求路径。
3. 在请求响应之前，会判断路径是否合法。
4. 合法则通过。不合法则进行拦截。并返回异常提示。

##### 输出未来三个月周五中午的时间戳

这种问题总是有点无力。觉得很简单。但是有时候API不是很熟悉。又答不上来。。Date也可以完成，只不过方法已经不建议使用了。使用日历类。遍历输出即可。

```java
  Calendar calendar =Calendar.getInstance();
  int now = calendar.get(Calendar.MONTH);
  SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  while (calendar.get(Calendar.MONTH)-now<=3){
    calendar.set(Calendar.WEEK_OF_YEAR,calendar.get(Calendar.WEEK_OF_YEAR)+1);
    System.out.println(df.format(calendar.getTime()));
  }
```

##### Spring定时任务执行两次的解决方案

这个问题总觉得有点蠢。面试遇到说无法排查。只能通过代码解决。当时觉得加程序计数器来限制。但是好像又不太对。百度下来有个使用AtomicLong 解决的方案。有点无语。这个问题有点蠢，第一直觉总觉得应该盘查问题的。可能是想考察多线程原子操作类。

整体思路是让一个线程去执行。这里使用了AtomicLong的getAndSet 判断时间是否是当前时间。AtomicLong的getAndSet会返回上一次的执行时间，如果一致说明已经执行过了。

```java
@Component
@EnableScheduling
public class ScheduledJobs {
    static AtomicLong atomicInteger = new AtomicLong();
    @Autowired
    SubscribeAndBindCardService subscribeAndBindCardService;
 
    /**
     * 每天凌晨1点统计前一天粉丝数据
     */
    @Scheduled(cron = "0 0 1 * * ?")
    private void makeSubscribeAndBindCardData() {
 
        // 这里的atomicInteger 是为了解决 该定时任务每次调用都执行两次的问题。
        long currentDate = LocalDate.now().toEpochDay();
        if (atomicInteger.getAndSet(currentDate) != currentDate) {
            System.out.println(Thread.currentThread());
            System.out.println("LocalDate.now() = " + LocalDate.now());
            try {
                // 统计前一天的数据
                LocalDate statDate = LocalDate.now().minusDays(1);
                subscribeAndBindCardService.makeData(statDate, statDate);
            } catch (Exception exception) {
                exception.printStackTrace();
            }
        }
 
 
    }
}
```

